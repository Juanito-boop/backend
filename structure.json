{
  "src": {
    "config": {
      "api": {
        "Server.ts": "import   cors         from \"cors\";\r\nimport { config     } from \"dotenv\";\r\nimport   express      from \"express\";\r\nimport   morgan       from \"morgan\";\r\nimport   portfinder   from 'portfinder';\r\n\r\nimport seguridad       \t  from \"../../middleware/Seguridad\";\r\nimport rutasUsuario    \t  from \"../../routes/rutasUsuario\";\r\nimport rutasSinMiddleware from \"../../routes/rutasSinMiddleware\";\r\nimport tokenRuta          from \"../../routes/TokenRuta\";\r\n\r\nclass Servidor {\r\n\tpublic app: express.Application;\r\n\tpublic port: String;\r\n\tv1: string = \"/api/v1/public\";\r\n\r\n\tconstructor() {\r\n\t\tthis.app = express();\r\n\t\tconfig({ path: \"./.env\" });\r\n\t\tthis.port = process.env.SERVER_PORT || \"8082\";\r\n\t\tthis.iniciarConfig();\r\n\t\tthis.activarRutas();\r\n\t}\r\n\r\n\tpublic iniciarConfig(): void {\r\n\t\tthis.app.set(\"PORT\", this.port);\r\n\t\tthis.app.use(cors());\r\n\t\tthis.app.use(morgan(\"dev\"));\r\n\t\tthis.app.use(express.json({ limit: \"100mb\" }));\r\n\t\tthis.app.use(express.urlencoded({ extended: true }));\r\n\t}\r\n\r\n\tpublic activarRutas(): void {\r\n\t\tthis.app.get(\"/\", (_req, res) => {\r\n\t\t\tres.send(\"hello world\");\r\n\t\t});\r\n\t\tthis.app.use(`${this.v1}/token`, tokenRuta); // listo\r\n\t\tthis.app.use(`${this.v1}/crearUsuarios`, rutasSinMiddleware) //listo\r\n\t\tthis.app.use(`${this.v1}/usuarios`, seguridad.revisar, rutasUsuario); // listo\r\n\t}\r\n\r\n\tpublic arrancar(): void {\r\n\t\tconst puerto = this.app.get(\"PORT\");\r\n\r\n\t\tportfinder.basePort = parseInt(puerto, 10); // Establece el puerto base para portfinder\r\n\t\tportfinder\r\n\t\t\t.getPortPromise()\r\n\t\t\t.then((port) => {\r\n\t\t\t\tthis.app.listen(port, () => {\r\n\t\t\t\t\tconsole.log(`Servidor corriendo en el puerto ${port}`);\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\t.catch((err) => {\r\n\t\t\t\tconsole.error(\"No se pudo encontrar un puerto disponible:\", err);\r\n\t\t\t});\r\n\t}\r\n}\r\n\r\nexport default Servidor;\r\n"
      },
      "connection": {
        "conexion.ts": "import pgPromise from \"pg-promise\";\r\nimport { opcionesPG } from \"./opcionConexion\";\r\nimport variablesConexion from \"../domain/varDB\";\r\nimport Result from \"../../utils/Result\";\r\n\r\nconst pgp = pgPromise(opcionesPG);\r\nconst pool = pgp(variablesConexion);\r\nconst dbname = variablesConexion.database;\r\n\r\npool.connect()\r\n    .then((conn) => {\r\n        console.log(\"Conexion exitosa con DB: \", dbname);\r\n        conn.done();\r\n    })\r\n    .catch((error) => {\r\n        return Result.fail(`Error al conectar con la base de datos: ${error.message}`);\r\n    });\r\n\r\nexport default pool;\r\n",
        "funcionConexion.ts": "import pgPromise from \"pg-promise\"\r\n\r\nexport interface IClient {\r\n}\r\n\r\nexport function camelizeColumns(data: any) {\r\n\tconst tmp = data[0];\r\n\tfor (const prop in tmp) {\r\n\t\tconst camel = pgPromise.utils.camelize(prop); //a\r\n\t\tif (!(camel in tmp)) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tconst d = data[i];\r\n\t\t\t\td[camel] = d[prop];\r\n\t\t\t\tdelete d[prop];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}",
        "opcionConexion.ts": "import pgPromise from \"pg-promise\";\r\nimport { camelizeColumns, IClient } from \"./funcionConexion\";\r\n\r\nexport const opcionesPG: pgPromise.IInitOptions<IClient> = {\r\n\treceive(data){\r\n\t\tcamelizeColumns(data);\r\n\t},\r\n};"
      },
      "domain": {
        "varDB.ts": "import { config } from \"dotenv\";\r\nconfig({ path: \"./.env\" });\r\n\r\nexport default {\r\n\tuser : process.env.DB_USER || \"user_js\",\r\n\tpassword: process.env.DB_PASSWORD || \"0000\",\r\n\thost: process.env.DB_HOST || \"localhost\",\r\n\tport: Number(process.env.DB_PORT) || 5432,\r\n\tdatabase: process.env.DB_NAME || \"postgres\"\r\n};\r\n"
      }
    },
    "controllers": {
      "tokenController.ts": "import { Request, Response } from \"express\";\r\nimport tokenDAO from \"../dao/tokenDAO\";\r\nimport bcrypt from \"bcrypt\";\r\n\r\nclass tokenController {\r\n  public async createToken(req: Request, res: Response): Promise<void> {\r\n    const { username, password } = req.body;\r\n\r\n    try {\r\n      const result = await tokenDAO.getUserCredentials(username);\r\n\r\n      if (!result.isSuccess) {\r\n        res.status(400).json({ Respuesta: result.errorValue() });\r\n        return;\r\n      }\r\n\r\n      const user = result.getValue();\r\n\r\n      const isPasswordValid = await bcrypt.compare(password, user.password);\r\n\r\n      if (!isPasswordValid) {\r\n        res.status(401).json({ Respuesta: \"Credenciales inválidas\" });\r\n        return;\r\n      }\r\n\r\n      const tokenResult = await tokenDAO.generateToken([\r\n        username,\r\n        user.password,\r\n      ]);\r\n\r\n      if (tokenResult.isSuccess) {\r\n        res.status(200).json(tokenResult.getValue());\r\n      } else {\r\n        res.status(400).json(tokenResult.errorValue());\r\n      }\r\n    } catch (error: any) {\r\n      res\r\n        .status(500)\r\n        .json({ Respuesta: `Error al iniciar sesión: ${error.message}` });\r\n    }\r\n  }\r\n}\r\nconst TokenController = new tokenController();\r\nexport default TokenController;\r\n",
      "usuarioController.ts": "import bcrypt from \"bcrypt\";\r\nimport { Request, Response } from \"express\";\r\nimport UsuarioDAO from \"../dao/usuarioDAO\";\r\nimport { User, UsuarioCreationResult } from \"../interface/interfaces\";\r\nimport Result from \"../utils/Result\";\r\n\r\nclass usuarioController {\r\n\tpublic async insertUser(req: Request, res: Response): Promise<void> {\r\n\t\tconst { nombre, apellido, email, username, password, avatar_url, role } =\r\n\t\t\treq.body;\r\n\r\n\t\tif (\r\n\t\t\ttypeof nombre !== \"string\" ||\r\n\t\t\ttypeof apellido !== \"string\" ||\r\n\t\t\ttypeof email !== \"string\" ||\r\n\t\t\ttypeof username !== \"string\" ||\r\n\t\t\ttypeof password !== \"string\" ||\r\n\t\t\ttypeof avatar_url !== \"string\" ||\r\n\t\t\ttypeof role !== \"number\"\r\n\t\t) {\r\n\t\t\tres.status(400).json({ Respuesta: \"Invalid input data types\" });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tconst saltRounds = 10;\r\n\t\t\tconst hashedPassword = await bcrypt.hash(password, saltRounds);\r\n\r\n\t\t\tconst data = { nombre, apellido, email, username, password: hashedPassword, avatar_url, role,};\r\n\t\t\tconst result: Result<UsuarioCreationResult, string> =\r\n\t\t\t\tawait UsuarioDAO.createUser(data);\r\n\r\n\t\t\tif (result.isSuccess) {\r\n\t\t\t\tres.status(200).json(result.getValue());\r\n\t\t\t} else {\r\n\t\t\t\tres.status(400).json({ Respuesta: result.errorValue() });\r\n\t\t\t}\r\n\t\t} catch (error: any) {\r\n\t\t\tres\r\n\t\t\t\t.status(500)\r\n\t\t\t\t.json({ Respuesta: `Error al crear el usuario: ${error.message}` });\r\n\t\t}\r\n\t}\r\n\r\n\tpublic async insertMultipleUsers(req: Request, res: Response): Promise<void> {\r\n\t\tconst users = req.body;\r\n\r\n\t\tif (!Array.isArray(users)) {\r\n\t\t\tres.status(400).json({ Respuesta: \"Se esperaba un array de usuarios\" });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tconst insertions = users.map(async (user) => {\r\n\t\t\t\tconst { nombre, apellido, email, username, password, avatar_url, role } = user;\r\n\r\n\t\t\t\tif (!password) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\"Contraseña no proporcionada para el usuario \" + username\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst saltRounds = 10;\r\n\t\t\t\tconst hashedPassword = await bcrypt.hash(password, saltRounds);\r\n\t\t\t\tconst userData = { nombre, apellido, email, username, password: hashedPassword, avatar_url, role };\r\n\r\n\t\t\t\treturn UsuarioDAO.createUser(userData);\r\n\t\t\t});\r\n\r\n\t\t\tconst results = await Promise.all(insertions);\r\n\t\t\tconst failed = results.filter((result) => !result.isSuccess);\r\n\r\n\t\t\tif (failed.length > 0) {\r\n\t\t\t\tres\r\n\t\t\t\t\t.status(400)\r\n\t\t\t\t\t.json({ Respuesta: \"Error en algunas inserciones\", errores: failed });\r\n\t\t\t} else {\r\n\t\t\t\tres\r\n\t\t\t\t\t.status(200)\r\n\t\t\t\t\t.json({ Respuesta: \"Todos los usuarios insertados exitosamente\" });\r\n\t\t\t}\r\n\t\t} catch (error: any) {\r\n\t\t\tres\r\n\t\t\t\t.status(500)\r\n\t\t\t\t.json({ Respuesta: `Error al crear usuarios: ${error.message}` });\r\n\t\t}\r\n\t}\r\n\tpublic async fetchUser(req: Request, res: Response): Promise<void> {\r\n\t\tconst username: string = req.params.username;\r\n\t\ttry {\r\n\t\t\tawait UsuarioDAO.updateUserLoginTimestamp(username);\r\n\t\t\tconst result: Result<User, string> = await UsuarioDAO.getUser(username);\r\n\r\n\t\t\tif (result.isSuccess) {\r\n\t\t\t\tres.status(200).json(result.getValue());\r\n\t\t\t} else {\r\n\t\t\t\tres.status(400).json({ Respuesta: result.errorValue() });\r\n\t\t\t}\r\n\t\t} catch (error: any) {\r\n\t\t\tres\r\n\t\t\t\t.status(500)\r\n\t\t\t\t.json({ Respuesta: `Error al obtener el usuario: ${error.message}` });\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst UsuarioController = new usuarioController();\r\nexport default UsuarioController;"
    },
    "dao": {
      "tokenDAO.ts": "import { config } from \"dotenv\";\r\nimport Jwt from \"jsonwebtoken\";\r\nimport pool from \"../config/connection/conexion\";\r\nimport { DataToken, Token } from \"../interface/interfaces\";\r\nimport { SQL_TOKEN } from \"../repository/crudSQL\";\r\nimport Result from \"../utils/Result\";\r\n\r\nconfig({ path: \"./.env\" });\r\n\r\nexport default class tokenDAO {\r\n\tpublic static async generateToken(data: Token[]): Promise<Result<string>> {\r\n\t\ttry {\r\n\t\t\tconst result = await pool.result(SQL_TOKEN.getUserToken, data);\r\n\r\n\t\t\tif (result.rows.length === 0) {\r\n\t\t\t\treturn Result.fail(\"No se encontraron registros\");\r\n\t\t\t}\r\n\r\n\t\t\tconst { username, role } = result.rows[0] as DataToken;\r\n\t\t\tconst secretKey = process.env.JWT_SECRET_KEY || \"LaSuperClave\";\r\n\r\n      const token = Jwt.sign({ username, role }, secretKey, {\r\n        expiresIn: \"10000d\",\r\n      });\r\n\r\n\t\t\treturn Result.success(token);\r\n\t\t} catch (error: any) {\r\n\t\t\treturn Result.fail(`No se puede generar el token, ${error.message}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static async getUserCredentials(username: string): Promise<Result<{ password: string }>> {\r\n\t\ttry {\r\n\t\t\tconst result = await pool.one(SQL_TOKEN.getUserCredentials, [username]);\r\n\t\t\treturn Result.success(result);\r\n\t\t} catch (error: any) {\r\n\t\t\treturn Result.fail(\r\n\t\t\t\t`No se puede obtener las credenciales del usuario: ${error.message}`\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}",
      "usuarioDAO.ts": "import pool from \"../config/connection/conexion\";\r\nimport { User, UsuarioCreationResult } from \"../interface/interfaces\";\r\nimport { SQL_USUARIO } from \"../repository/crudSQL\";\r\nimport Result from \"../utils/Result\";\r\n\r\nexport default class UsuarioDAO {\r\n\tpublic static async createUser(data: Omit<User, \"user_id\" |\"created_at\"| \"updated_at\">): Promise<Result<UsuarioCreationResult>> {\r\n\t\tconst { email, username } = data;\r\n\r\n\t\tconst existingUser = await pool.oneOrNone(SQL_USUARIO.checkUserExists, [email, username]);\r\n\t\treturn existingUser?.exists? Result.fail(\"El usuario ya existe\"): await this.insertNewUser(data);\r\n\t}\r\n\r\n\tprivate static async insertNewUser(data: Omit<User, \"user_id\" |\"created_at\"| \"updated_at\">): Promise<Result<UsuarioCreationResult>> {\r\n\t\ttry {\r\n\t\t\tconst result = await pool.task(async (consulta) => {\r\n\t\t\t\treturn await consulta.one<UsuarioCreationResult>(\r\n\t\t\t\t\tSQL_USUARIO.insertUser,\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\tdata.nombre, data.apellido, data.email,\r\n\t\t\t\t\t\tdata.username, data.password, data.avatar_url,\r\n\t\t\t\t\t\tdata.role,\r\n\t\t\t\t\t]\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t\treturn Result.success({ user_id: result.user_id });\r\n\t\t} catch (error) {\r\n\t\t\treturn Result.fail(`No se puede crear el usuario, El usuario ya existe\\n ${error}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static async getUser(username: string): Promise<Result<User>> {\r\n\t\ttry {\r\n\t\t\tconst result: User = await pool.one(SQL_USUARIO.fetchUser, username);\r\n\t\t\treturn Result.success(result);\r\n\t\t} catch (error) {\r\n\t\t\treturn Result.fail(`No se puede obtener los usuarios, ${error}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static async updateUserLoginTimestamp(username: string): Promise<void> {\r\n\t\ttry {\r\n\t\t\tconst query = `UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE username = $1;`;\r\n\t\t\tawait pool.none(query, username);\r\n\t\t} catch (error: any) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Error al actualizar el timestamp de login: ${error.message}`\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}"
    },
    "index.ts": "import Server from \"./config/api/Server\";\r\n\r\nconst server = new Server();\r\n\r\nserver.arrancar();",
    "interface": {
      "interfaces.ts": "export interface User {\r\n\tuser_id:    string;\r\n\tnombre:     string;\r\n\tapellido:   string;\r\n\temail:      string;\r\n\tusername:   string;\r\n\tpassword: \tstring;\r\n\tavatar_url: string;\r\n\trole: \t\t\tnumber;\r\n\tcreated_at: Date;\r\n\tupdated_at: Date;\r\n}\r\n\r\nexport interface Token {\r\n\tusername: string;\r\n\tpassword: string;\r\n}\r\n\r\nexport interface DataToken{\r\n\tusername: string;\r\n\trole: string;\r\n}\r\n\r\nexport interface UsuarioCreationResult {\r\n  user_id: string;\r\n}\r\n"
    },
    "middleware": {
      "Cache.ts": "import { Request, Response, NextFunction } from 'express';\r\nimport cache from '../utils/Cache';\r\n\r\n// Extendemos el tipo Response para incluir sendResponse\r\ndeclare module 'express-serve-static-core' {\r\n\tinterface Response {\r\n\t\tsendResponse?: (body?: any) => Response;\r\n\t}\r\n}\r\n\r\nconst generateCacheKey = (req: Request): string => {\r\n\treturn `${req.method}-${req.originalUrl}`;\r\n};\r\n\r\nconst cacheMiddleware = () => {\r\n\treturn (req: Request, res: Response, next: NextFunction) => {\r\n\t\tconst key = generateCacheKey(req);\r\n\t\tconst cachedResponse = cache.get(key);\r\n\t\tif (cachedResponse) {\r\n\t\t\tres.send(cachedResponse);\r\n\t\t} else {\r\n\t\t\tres.sendResponse = res.send;\r\n\t\t\tres.send = (body: any): Response<any, Record<string, any>> => { // Update the type of the res.send function\r\n\t\t\t\tcache.set(key, body);\r\n\t\t\t\treturn res.sendResponse?.(body) as Response<any, Record<string, any>>; // Return the response\r\n\t\t\t};\r\n\t\t\tnext();\r\n\t\t}\r\n\t};\r\n}\r\n\r\n\r\nexport default cacheMiddleware;",
      "Seguridad.ts": "import jwt from \"jsonwebtoken\";\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport { config } from \"dotenv\";\r\n\r\nconfig({ path: \"./.env\" });\r\n\r\nclass Seguridad {\r\n\tpublic revisar(req: Request, res: Response, next: NextFunction) {\r\n\t\tconst authHeader = req.headers.authorization;\r\n\r\n\t\tif (!authHeader) {\r\n\t\t\treturn res.status(401).json({ Respuesta: \"Falta el token de autorización\" });\r\n\t\t}\r\n\r\n\t\tconst tokenParts = authHeader.split(\" \");\r\n\t\tif (tokenParts.length !== 2 || tokenParts[0] !== \"Bearer\") {\r\n\t\t\treturn res.status(401).json({ Respuesta: \"Formato del token incorrecto\" });\r\n\t\t}\r\n\r\n\t\tconst token = tokenParts[1];\r\n\t\ttry {\r\n\t\t\tconst secretKey = process.env.JWT_SECRET_KEY || 'LaSuperClave';\r\n\t\t\tconst decoded = jwt.verify(token, secretKey);\r\n\t\t\t(req as any).user = decoded; // Attach decoded token to the request object\r\n\t\t\tnext();\r\n\t\t} catch (error) {\r\n\t\t\tif (error instanceof jwt.TokenExpiredError) {\r\n\t\t\t\treturn res.status(401).json({ Respuesta: \"El token ha expirado\" });\r\n\t\t\t} else if (error instanceof jwt.JsonWebTokenError) {\r\n\t\t\t\treturn res.status(401).json({ Respuesta: \"El token no es válido\" });\r\n\t\t\t} else {\r\n\t\t\t\treturn res.status(500).json({ Respuesta: \"Error al procesar el token\" });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst seguridad = new Seguridad();\r\nexport default seguridad;\r\n"
    },
    "repository": {
      "crudSQL.ts": "export const SQL_TOKEN = {\r\n  getUserToken: `\r\n\t  SELECT \r\n\t\t\tu.username, \r\n\t\t\tr.nombre_rol AS role \r\n\t  FROM users u \r\n\t  INNER JOIN roles r ON r.id_rol = u.role \r\n\t  WHERE u.username = $1 AND u.password = $2`,\r\n  getUserCredentials: `\r\n\t\tSELECT \r\n\t\t\tpassword \r\n\t\tFROM users \r\n\t\tWHERE username = $1;`,\r\n};\r\n\r\nexport const SQL_USUARIO = {\r\n  fetchUser: `\r\n\t\tSELECT \r\n\t\t\tusers.user_id, users.nombre, users.apellido, \r\n\t\t\tusers.email, users.username, users.avatar_url, \r\n\t\t\troles.nombre_rol as rol, created_at, updated_at\r\n\t\tFROM users \r\n\t\tJOIN roles ON users.role = roles.id_rol \r\n\t\tWHERE users.username = $1;`,\r\n  findAllUsers: `\r\n\t\tSELECT \r\n\t\t\tusers.nombre, users.apellido, users.username, \r\n\t\t\troles.nombre_rol as rol\r\n\t\tFROM users \r\n\t\tJOIN roles ON users.role = roles.id_rol;`,\r\n  insertUser: `\r\n\t\tINSERT INTO \r\n\t\t\tusers (\r\n\t\t\t\tnombre, apellido, email, \r\n\t\t\t\tusername, password, avatar_url, \r\n\t\t\t\trole, created_at, updated_at) \r\n\t\tVALUES (\r\n\t\t\t$1, $2, $3, \r\n\t\t\t$4, $5, $6, \r\n\t\t\t$7, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) \r\n\t\tRETURNING user_id;`,\r\n  checkUserExists: `\r\n\t\tSELECT \r\n\t\t\tuser_id \r\n\t\tFROM users \r\n\t\tWHERE email = $1 OR username = $2;`,\r\n};"
    },
    "routes": {
      "rutasSinMiddleware.ts": "import { Router } from \"express\";\r\n\r\nimport UsuarioController from \"../controllers/usuarioController\";\r\n// import cacheMiddleware from \"../middleware/Cache\";\r\n\r\nclass Rutas {\r\n\tpublic rutasApi: Router;\r\n\tconstructor() {\r\n\t\tthis.rutasApi = Router();\r\n\t\tthis.config();\r\n\t}\r\n\tpublic config() {\r\n\tthis.rutas();\r\n\t}\r\n\tpublic rutas() {\r\n\t\tthis.rutasApi.post(\"/\", UsuarioController.insertUser);\r\n\t\tthis.rutasApi.post(\"/bulk\", UsuarioController.insertMultipleUsers);\r\n\t}\r\n}\r\nconst misRutas = new Rutas();\r\nexport default misRutas.rutasApi;",
      "rutasUsuario.ts": "import { Router } from \"express\";\r\n\r\nimport UsuarioController from \"../controllers/usuarioController\";\r\nimport cacheMiddleware from \"../middleware/Cache\";\r\n\r\nclass Rutas {\r\n  public rutasApi: Router;\r\n\r\n  constructor() {\r\n\tthis.rutasApi = Router();\r\n\tthis.config();\r\n  }\r\n\r\n  public config() {\r\n\tthis.rutas();\r\n  }\r\n  public rutas() {\r\n\t// /api/v1/public/usuarios\r\n\tthis.rutasApi.get(\r\n\t  \"/:username\",\r\n\t  cacheMiddleware(),\r\n\t  UsuarioController.fetchUser\r\n\t);\r\n  }\r\n}\r\n\r\nconst misRutas = new Rutas();\r\nexport default misRutas.rutasApi;\r\n",
      "TokenRuta.ts": "import { Router } from \"express\";\r\n\r\nimport TokenController from \"../controllers/tokenController\";\r\n\r\nclass TokenRuta {\r\n\tpublic tokenRutaApi: Router;\r\n\r\n\tconstructor() {\r\n\t\tthis.tokenRutaApi = Router();\r\n\t\tthis.lasRutas();\r\n\t}\r\n\r\n\tpublic lasRutas(): void {\r\n\t\t// /api/v1/public/token\r\n\t\tthis.tokenRutaApi.post(\"/\", TokenController.createToken);\r\n\t}\r\n}\r\nconst tokenRuta = new TokenRuta();\r\nexport default tokenRuta.tokenRutaApi;"
    },
    "utils": {
      "Cache.ts": "import NodeCache from 'node-cache';\r\n\r\nconst cache = new NodeCache({ stdTTL: 100, checkperiod: 120 });\r\n\r\nexport default cache;",
      "Result.ts": "class Result<T, E = string> {\r\n\tpublic isSuccess: boolean;\r\n\tpublic isFailure: boolean;\r\n\tpublic error: E | null;\r\n\tprivate value: T | null;\r\n\r\n\tprivate constructor(isSuccess: boolean, error?: E, value?: T) {\r\n\t\tif (isSuccess && error) {\r\n\t\t\tthrow new Error(\"InvalidOperation: A result cannot be successful and contain an error\");\r\n\t\t}\r\n\t\tif (!isSuccess && !error) {\r\n\t\t\tthrow new Error(\"InvalidOperation: A failing result needs to contain an error message\");\r\n\t\t}\r\n\r\n\t\tthis.isSuccess = isSuccess;\r\n\t\tthis.isFailure = !isSuccess;\r\n\t\tthis.error = error || null;\r\n\t\tthis.value = value || null;\r\n\t}\r\n\r\n\tpublic getValue(): T {\r\n\t\tif (!this.isSuccess) {\r\n\t\t\tthrow new Error(\"Can't get the value of an error result. Use 'errorValue' instead.\");\r\n\t\t}\r\n\r\n\t\treturn this.value as T;\r\n\t}\r\n\r\n\tpublic errorValue(): E {\r\n\t\treturn this.error as E;\r\n\t}\r\n\r\n\tpublic static success<U>(value?: U): Result<U> {\r\n\t\treturn new Result<U>(true, undefined, value);\r\n\t}\r\n\r\n\tpublic static fail<U, F>(error: F): Result<U, F> {\r\n\t\treturn new Result<U, F>(false, error);\r\n\t}\r\n}\r\n\r\nexport default Result;\r\n"
    }
  }
}