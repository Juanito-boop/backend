{
  "src": {
    "config": {
      "api": {
        "Server.ts": "import   cors         from \"cors\";\r\nimport { config     } from \"dotenv\";\r\nimport   express      from \"express\";\r\nimport   morgan       from \"morgan\";\r\nimport   portfinder   from 'portfinder';\r\n\r\nimport seguridad       from \"../../middleware/Seguridad\";\r\nimport rutasCategorias from \"../../routes/rutasCategorias\";\r\nimport rutasDetalles   from \"../../routes/rutasDetalles\";\r\nimport rutasFacturas   from \"../../routes/rutasFacturas\";\r\nimport rutasProductos  from \"../../routes/rutasProductos\";\r\nimport rutasTienda     from \"../../routes/rutasTienda\";\r\nimport rutasUsuario    from \"../../routes/rutasUsuario\";\r\nimport tokenRuta       from \"../../routes/TokenRuta\";\r\n\r\nclass Servidor {\r\n    public app: express.Application;\r\n    public port: String;\r\n    v1:string = \"/api/v1/public\"\r\n\r\n    constructor() {\r\n        this.app = express();\r\n        config({ path: \"./.env\" });\r\n        this.port = process.env.SERVER_PORT || \"8082\";\r\n        this.iniciarConfig();\r\n        this.activarRutas();\r\n    }   \r\n\r\n    public iniciarConfig(): void {\r\n        this.app.set(\"PORT\", this.port);\r\n        this.app.use(cors());\r\n        this.app.use(morgan(\"dev\"));\r\n        this.app.use(express.json({ limit: \"100mb\" }));\r\n        this.app.use(express.urlencoded({ extended: true }));\r\n    }\r\n\r\n    public activarRutas(): void {\r\n        this.app.get(\"/\", (_req, res) => {res.send(\"hello world\")});\r\n        this.app.use(`${this.v1}/categorias`, seguridad.revisar, rutasCategorias);// listo\r\n        this.app.use(`${this.v1}/detalles`, seguridad.revisar, rutasDetalles);\r\n        this.app.use(`${this.v1}/facturas`, seguridad.revisar, rutasFacturas);// listo\r\n        this.app.use(`${this.v1}/productos`, seguridad.revisar, rutasProductos);// listo\r\n        this.app.use(`${this.v1}/tiendas`, seguridad.revisar, rutasTienda);// listo\r\n        this.app.use(`${this.v1}/token`, tokenRuta);// listo\r\n        this.app.use(`${this.v1}/usuarios`, seguridad.revisar, rutasUsuario);// listo\r\n    }    \r\n    \r\n    public arrancar(): void {\r\n        const puerto = this.app.get(\"PORT\");\r\n\r\n        portfinder.basePort = parseInt(puerto, 10);  // Establece el puerto base para portfinder\r\n        portfinder.getPortPromise()\r\n            .then((port) => {\r\n                this.app.listen(port, () => {\r\n                    console.log(`Servidor corriendo en el puerto ${port}`);\r\n                });\r\n            })\r\n            .catch((err) => {\r\n                console.error(\"No se pudo encontrar un puerto disponible:\", err);\r\n            });\r\n    }\r\n}\r\n\r\nexport default Servidor;\r\n"
      },
      "connection": {
        "conexion.ts": "import pgPromise from \"pg-promise\";\r\nimport { opcionesPG } from \"./opcionConexion\";\r\nimport variablesConexion from \"../domain/varDB\";\r\n\r\nconst pgp = pgPromise(opcionesPG);\r\nconst pool = pgp(variablesConexion);\r\nconst dbname = variablesConexion.database;\r\n\r\npool\r\n  .connect()\r\n  .then((conn) => {\r\n    console.log(\"Conexion exitosa con DB: \", dbname);\r\n\r\n    conn.done();\r\n  })\r\n  .catch((mierror) => {\r\n    console.log(mierror);\r\n  });\r\n\r\nexport default pool;",
        "funcionConexion.ts": "import pgPromise from \"pg-promise\"\r\n\r\nexport interface IClient {\r\n}\r\n\r\nexport function camelizeColumns(data: any) {\r\n    const tmp = data[0];\r\n    for (const prop in tmp) {\r\n        const camel = pgPromise.utils.camelize(prop); //a\r\n        if (!(camel in tmp)) {\r\n            for (let i = 0; i < data.length; i++) {\r\n                const d = data[i];\r\n                d[camel] = d[prop];\r\n                delete d[prop];\r\n            }\r\n        }\r\n    }\r\n}",
        "opcionConexion.ts": "import pgPromise from \"pg-promise\";\r\nimport { camelizeColumns, IClient } from \"./funcionConexion\";\r\n\r\nexport const opcionesPG: pgPromise.IInitOptions<IClient> = {\r\n    receive(data){\r\n        camelizeColumns(data);\r\n    },\r\n};"
      },
      "domain": {
        "varDB.ts": "import { config } from \"dotenv\";\r\nconfig({ path: \"./.env\" });\r\n\r\nexport default {\r\n    user : process.env.DB_USER || \"user_js\",\r\n    password: process.env.DB_PASSWORD || \"0000\",\r\n    host: process.env.DB_HOST || \"localhost\",\r\n    port: Number(process.env.DB_PORT) || 5432,\r\n    database: process.env.DB_NAME || \"postgres\"\r\n};\r\n"
      }
    },
    "controllers": {
      "categoriaController.ts": "import { Request, Response } from \"express\";\r\nimport CategoriaDAO from \"../dao/categoriaDAO\";\r\nimport { Categoria } from \"../interface/interfaces\";\r\n\r\nclass CategoriaController {\r\n  public async insertCategory(req: Request, res: Response): Promise<void> {\r\n    const { nombre, descripcion, id_tienda } = req.body;\r\n    const data: Categoria[] = [\r\n      nombre,\r\n      descripcion,\r\n      id_tienda\r\n    ];\r\n\r\n    const result = await CategoriaDAO.insertCategory(data);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getStoreCategories(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda no es un numero\" });\r\n      return;\r\n    }\r\n\r\n    const result = await CategoriaDAO.fetchCategories(tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getFilteredCategoryByStoreAndId(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idCategoria: number = parseInt(req.params.idCategoria);\r\n\r\n    if (isNaN(tienda) || isNaN(idCategoria)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda o de la categoria no es un numero\" });\r\n      return;\r\n    }\r\n\r\n    const result = await CategoriaDAO.filterCategoryIdByStore(tienda, idCategoria);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async patchStoreCategory(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idCategoria: number = parseInt(req.params.idCategoria);\r\n    const fieldsToUpdate: Categoria = req.body;\r\n\r\n    if (isNaN(tienda) || isNaN(idCategoria)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda o de la categoria no es un numero\" });\r\n      return;\r\n    }\r\n\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      res.status(400).json({ Respuesta: \"No se proporcionaron campos para actualizar\" });\r\n      return;\r\n    }\r\n\r\n    const result = await CategoriaDAO.updateCategory(fieldsToUpdate, tienda, idCategoria);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: result.getValue() });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async deleteStoreCategoryId(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idCategoria: number = parseInt(req.params.idCategoria);\r\n\r\n    if (isNaN(tienda) || isNaN(idCategoria)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda o de la categoria no es un numero\" });\r\n      return;\r\n    }\r\n\r\n    const result = await CategoriaDAO.deleteCategory(tienda, idCategoria);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: result.getValue() });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nconst categoriaController = new CategoriaController();\r\nexport default categoriaController;\r\n",
      "detallesFacturaController.ts": "import { Request, Response } from \"express\";\r\nimport DetalleFacturaDAO from \"../dao/detalleFacturaDAO\";\r\n\r\nclass DetallesFacturaController {\r\n  public async insertInvoiceWithDetails(req: Request, res: Response): Promise<void> {\r\n    const { factura, detalles } = req.body;\r\n\r\n    // Validación de los datos de entrada\r\n    if (!factura || !Array.isArray(detalles)) {\r\n      res.status(400).json({ Respuesta: \"Invalid input data types\" });\r\n      return;\r\n    }\r\n\r\n    const result = await DetalleFacturaDAO.insertInvoiceWithDetails(factura, detalles);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getStoreInvoices(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await DetalleFacturaDAO.fetchStoreInvoices(tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nconst detallesFacturaController = new DetallesFacturaController();\r\nexport default detallesFacturaController;",
      "FacturaController.ts": "import { Request, Response } from \"express\";\r\nimport FacturaDAO from \"../dao/FacturaDAO\";\r\nimport { Factura } from \"../interface/interfaces\";\r\n\r\nclass FacturaController {\r\n  public async insertInvoice(req: Request, res: Response): Promise<void> {\r\n    const { fecha_venta, vendedor_factura, cantidad_producto, id_tienda } = req.body;\r\n    const data: Factura[] = [\r\n      fecha_venta,\r\n      vendedor_factura,\r\n      cantidad_producto,\r\n      id_tienda\r\n    ];\r\n    const result = await FacturaDAO.insertInvoice(data);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getStoreInvoices(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.fetchStoreInvoices(tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getFilteredInvoicesByStoreAndId(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idFactura: number = parseInt(req.params.idFactura);\r\n\r\n    if (isNaN(tienda) || isNaN(idFactura)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda y de la factura deben ser números\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.filterInvoiceIdByStore(tienda, idFactura);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async patchStoreInvoice(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idFactura: number = parseInt(req.params.idFactura);\r\n    const fieldsToUpdate: Factura = req.body;\r\n\r\n    if (isNaN(tienda) || isNaN(idFactura)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda y de la factura deben ser números\" });\r\n      return;\r\n    }\r\n\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      res.status(400).json({ Respuesta: \"No se proporcionaron campos para actualizar\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.updateInvoice(fieldsToUpdate, idFactura, tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: result.getValue() });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async deleteStoreInvoiceId(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idFactura: number = parseInt(req.params.idFactura);\r\n\r\n    if (isNaN(tienda) || isNaN(idFactura)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda y de la factura deben ser números\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.deleteInvoice(tienda, idFactura);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: result.getValue() });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getStoreAnnualInvoices(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.countInvoicesTypeByStore(tienda, 'anual');\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getStoreMonthlyInvoices(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.countInvoicesTypeByStore(tienda, 'mensual');\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async getStoreDailyInvoices(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await FacturaDAO.countInvoicesTypeByStore(tienda, 'diaria');\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nconst controladorFacturas = new FacturaController();\r\nexport default controladorFacturas;\r\n",
      "productoController.ts": "import { Request, Response } from 'express';\r\nimport { Producto } from '../interface/interfaces';\r\nimport productoDAO from '../dao/productoDAO';\r\n\r\nclass ProductoController {\r\n  public static async createProduct(req: Request, res: Response): Promise<void> {\r\n    const { nombre, marca, precio_unitario, fecha_caducidad, descripcion, stock, id_categoria, id_tienda } = req.body;\r\n    const data: Producto[] = [ \r\n      nombre, \r\n      marca, \r\n      precio_unitario, \r\n      fecha_caducidad, \r\n      descripcion, \r\n      stock, \r\n      id_categoria, \r\n      id_tienda \r\n    ];\r\n    const result = await productoDAO.insertProduct(data);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public static async fetchProducts(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await productoDAO.fetchProducts(tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public static async filterProductById(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idProducto: number = parseInt(req.params.idProducto);\r\n\r\n    if (isNaN(tienda) || isNaN(idProducto)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda y del producto deben ser números\" });\r\n      return;\r\n    }\r\n\r\n    const result = await productoDAO.filterProductById(tienda, idProducto);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public static async updateProduct(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idProducto: number = parseInt(req.params.idProducto);\r\n    const fieldsToUpdate: Producto = req.body;\r\n\r\n    if (isNaN(tienda) || isNaN(idProducto)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda y del producto deben ser números\" });\r\n      return;\r\n    }\r\n\r\n    const result = await productoDAO.updateProduct(fieldsToUpdate, idProducto, tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: \"Producto actualizado\" });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public static async deleteProduct(req: Request, res: Response): Promise<void> {\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const idProducto: number = parseInt(req.params.idProducto);\r\n\r\n    if (isNaN(tienda) || isNaN(idProducto)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda y del producto deben ser números\" });\r\n      return;\r\n    }\r\n\r\n    const result = await productoDAO.deleteProduct(tienda, idProducto);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: \"Producto eliminado\" });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ProductoController;",
      "tiendaController.ts": "import { Request, Response } from \"express\";\r\nimport tiendaDAO from \"../dao/tiendaDAO\";\r\nimport { Tienda } from \"../interface/interfaces\";\r\n\r\nclass TiendaController {\r\n  public async insertStore(req: Request, res: Response): Promise<void> {\r\n    const data: Tienda[] = req.body;\r\n    const result = await tiendaDAO.addNewStore(data);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async fetchStores(_req: Request, res: Response): Promise<void> {\r\n    const result = await tiendaDAO.fetchStores();\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async fetchEmployeeCounterStores(req: Request, res: Response): Promise<void> {\r\n    const limit = parseInt(req.query.limit as string) || 50;\r\n    const offset = parseInt(req.query.offset as string) || 0;\r\n\r\n    const result = await tiendaDAO.fetchEmployeeCounterStores(limit, offset);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async filterStoreById(req: Request, res: Response): Promise<void> {\r\n    const idStore: number = parseInt(req.params.idTienda);\r\n    const result = await tiendaDAO.filterStoreById(idStore);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async patchStore(req: Request, res: Response): Promise<void> {\r\n    const idTienda: number = parseInt(req.params.idTienda);\r\n    const fieldsToUpdate: Tienda = req.body;\r\n\r\n    if (isNaN(idTienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await tiendaDAO.updateStore(fieldsToUpdate, idTienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: \"Tienda actualizada\" });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async deleteStore(req: Request, res: Response): Promise<void> {\r\n    const idTienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(idTienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda debe ser un número\" });\r\n      return;\r\n    }\r\n\r\n    const result = await tiendaDAO.deleteStore(idTienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: \"Tienda eliminada\" });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nconst tiendaController = new TiendaController();\r\nexport default tiendaController;\r\n",
      "tokenController.ts": "import { Request, Response } from \"express\";\r\nimport { Token } from \"../interface/interfaces\";\r\nimport tokenDAO from \"../dao/tokenDAO\";\r\n\r\nclass tokenController {\r\n  public async createToken(req: Request, res: Response): Promise<void> {\r\n    const { username, password } = req.body;\r\n    const data: Token[] = [username, password];\r\n\r\n    const result = await tokenDAO.generateToken(data);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue())\r\n    } else {\r\n      res.status(400).json({ respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nconst TokenController = new tokenController();\r\nexport default TokenController;",
      "usuarioController.ts": "import { Request, Response } from \"express\";\r\nimport { Usuario, UsuarioBulkResult, UsuarioCreationResult, UsuarioR } from \"../interface/interfaces\";\r\nimport UsuarioDAO from \"../dao/usuarioDAO\";\r\nimport Result from \"../utils/Result\";\r\n\r\nclass usuarioController {\r\n  public async insertUser(req: Request, res: Response): Promise<void> {\r\n    const { username, password, id_tienda, id_rol } = req.body;\r\n\r\n    if (typeof username  !== 'string' ||\r\n        typeof password  !== 'string' ||\r\n        typeof id_tienda !== 'number' ||\r\n        typeof id_rol    !== 'number'\r\n      ) {\r\n      res.status(400).json({ Respuesta: \"Invalid input data types\" });\r\n      return;\r\n    }\r\n\r\n    const data = { username, password, id_tienda, id_rol };\r\n    const result: Result<UsuarioCreationResult> = await UsuarioDAO.createUser(data);\r\n\r\n    if (result.isSuccess) {\r\n        res.status(200).json(result.getValue());\r\n    } else {\r\n        res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  } \r\n\r\n  public async insertUsers(req: Request, res: Response): Promise<void> {\r\n    const users: Omit<Usuario, 'id_usuario'>[] = req.body;\r\n    // Validación de datos de entrada\r\n    for (const user of users) {\r\n      const { username, password, id_tienda, id_rol } = user;\r\n      if (typeof username  !== 'string' ||\r\n          typeof password  !== 'string' ||\r\n          typeof id_tienda !== 'number' ||\r\n          typeof id_rol    !== 'number'\r\n        ) {\r\n        res.status(400).json({ Respuesta: \"Invalid input data types\" });\r\n        return;\r\n      }\r\n    }\r\n\r\n    const result: Result<UsuarioBulkResult> = await UsuarioDAO.createUsers(users);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json(result.errorValue());\r\n    }\r\n  }\r\n\r\n\r\n  public async fetchUsers(req: Request, res: Response): Promise<void>{\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    \r\n    if (isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id de la tienda no es un número válido\" });\r\n      return;\r\n    }\r\n    \r\n    const result = await UsuarioDAO.fetchUsers(tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async findAllUsers(req: Request, res: Response): Promise<void>{\r\n    const result: Result<UsuarioR[]> = await UsuarioDAO.finAllUsers();\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async findUser(req: Request, res: Response): Promise<void>{\r\n    const idUsuario: number = parseInt(req.params.idUsuario);\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    \r\n    if (isNaN(tienda) || isNaN(idUsuario)) {\r\n      res.status(400).json({ Respuesta: \"El id del usuario o de la tienda no es un número válido\" });\r\n      return;\r\n    }\r\n\r\n    const result = await UsuarioDAO.filterUserByStoreAndId(tienda, idUsuario);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json(result.getValue());\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async patchUser(req: Request, res: Response): Promise<void>{\r\n    const idUsuario: number = parseInt(req.params.idUsuario);\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n    const fieldsToUpdate = req.body;\r\n\r\n    if (isNaN(idUsuario) || isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id del usuario o de la tienda no es un número válido\" });\r\n      return;\r\n    }\r\n\r\n    const result = await UsuarioDAO.updateUser(fieldsToUpdate, idUsuario, tienda);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: \"Usuario actualizado\" });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n\r\n  public async deleteUser(req: Request, res: Response): Promise<void>{\r\n    const idUsuario: number = parseInt(req.params.idUsuario);\r\n    const tienda: number = parseInt(req.params.idTienda);\r\n\r\n    if (isNaN(idUsuario) || isNaN(tienda)) {\r\n      res.status(400).json({ Respuesta: \"El id del usuario o de la tienda no es un número válido\" });\r\n      return;\r\n    }\r\n    \r\n    const result = await UsuarioDAO.deleteUser(tienda, idUsuario);\r\n\r\n    if (result.isSuccess) {\r\n      res.status(200).json({ Respuesta: \"Usuario eliminado\" });\r\n    } else {\r\n      res.status(400).json({ Respuesta: result.errorValue() });\r\n    }\r\n  }\r\n}\r\n\r\nconst UsuarioController = new usuarioController();\r\nexport default UsuarioController;"
    },
    "dao": {
      "categoriaDAO.ts": "import pool from \"../config/connection/conexion\";\r\nimport { Categoria, CategoriaCreationResult, Exists } from \"../interface/interfaces\";\r\nimport { SQL_CATEGORIAS } from \"../repository/crudSQL\";\r\nimport Result from '../utils/Result';\r\n\r\nexport default class CategoriaDAO {\r\n  public static async insertCategory(data: Categoria[]): Promise<Result<CategoriaCreationResult>> {\r\n    const existingCategory: Exists | null = await pool.oneOrNone(SQL_CATEGORIAS.isCategoryDuplicate, [\r\n      data[0].nombre,\r\n      data[0].descripcion,\r\n      data[0].id_tienda\r\n    ]);\r\n\r\n    if (existingCategory?.exists) {\r\n      return Result.fail(\"La categoria ya existe\");\r\n    }\r\n\r\n    try {\r\n      const result: CategoriaCreationResult = await pool.task(async (consulta) => {\r\n        return await consulta.one<CategoriaCreationResult>(SQL_CATEGORIAS.createCategory, data);\r\n      });\r\n\r\n      return Result.success({ id_categoria: result.id_categoria });\r\n    } catch (error) {\r\n      return Result.fail(`No se puede crear la categoria, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async fetchCategories(tienda: number) {\r\n    try {\r\n      const respuesta: Categoria[] = await pool.manyOrNone(SQL_CATEGORIAS.getCategoriesByStoreId, tienda);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar las categorias de la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async filterCategoryIdByStore(tienda: number, idCategoria: number) {\r\n    try {\r\n      const respuesta: Categoria | null = await pool.oneOrNone<Categoria>(SQL_CATEGORIAS.getCategoriesByStoreAndId, [tienda, idCategoria]);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar la categoria de la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async updateCategory(fieldsToUpdate: { [key: string]: any },tienda: number,  idCategoria: number) {\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      return Result.fail(\"No se proporcionaron campos para actualizar\");\r\n    }\r\n\r\n    const existingCategory = await pool.oneOrNone(SQL_CATEGORIAS.checkCategoryExists, [tienda, idCategoria]);\r\n\r\n    if (!existingCategory) {\r\n      return Result.fail(\"Categoria no encontrada\");\r\n    }\r\n\r\n    try {\r\n      const setClause = Object.keys(fieldsToUpdate)\r\n        .map((field, index) => `${field} = $${index + 1}`)\r\n        .join(\", \");\r\n\r\n      const values = Object.values(fieldsToUpdate);\r\n      values.push(idCategoria, tienda);\r\n\r\n      const sqlUpdate = `UPDATE categorias SET ${setClause} WHERE id_categoria = $${values.length - 1} AND id_tienda = $${values.length}`;\r\n\r\n      const result = await pool.result(sqlUpdate, values);\r\n\r\n      if (result.rowCount > 0) {\r\n        return Result.success(\"Categoria actualizada\");\r\n      } else {\r\n        return Result.fail(\"Categoria no encontrada\");\r\n      }\r\n    } catch (error) {\r\n      return Result.fail(`No se puede actualizar la categoria, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async deleteCategory(tienda:number, idCategoria: number) {\r\n    const existingCategory = await pool.oneOrNone(SQL_CATEGORIAS.checkCategoryExists, [tienda, idCategoria]);\r\n\r\n    if (!existingCategory) {\r\n      return Result.fail(\"Categoria no encontrada\");\r\n    }\r\n\r\n    try {\r\n      const result = await pool.result(SQL_CATEGORIAS.deleteCategory, idCategoria);\r\n\r\n      if (result.rowCount > 0) {\r\n        return Result.success(\"Categoria eliminada\");\r\n      } else {\r\n        return Result.fail(\"Categoria no encontrada\");\r\n      }\r\n    } catch (error) {\r\n      return Result.fail(`No se puede eliminar la categoria, ${error}`);\r\n    }\r\n  }\r\n}",
      "detalleFacturaDAO.ts": "import pool from \"../config/connection/conexion\";\r\nimport { DetalleFactura, Factura, FacturaCreationResult } from \"../interface/interfaces\";\r\nimport { SQL_DETALLES, SQL_FACTURAS, SQL_PRODUCTOS } from \"../repository/crudSQL\";\r\nimport Result from \"../utils/Result\";\r\n\r\nexport default class DetalleFacturaDAO {\r\n  public static async insertInvoiceWithDetails(\r\n    factura: Omit<Factura, 'id_factura'>, \r\n    detalles: Omit<DetalleFactura, 'id_factura'>[]\r\n  ): Promise<Result<FacturaCreationResult>> {\r\n    try {\r\n      const result = await pool.task(async (consulta) => {\r\n        // Inserta la factura\r\n        const facturaValues: Omit<Factura, 'id_factura'> = {\r\n          fecha_venta: factura.fecha_venta, \r\n          vendedor_factura: factura.vendedor_factura, \r\n          cantidad_producto: factura.cantidad_producto, \r\n          id_tienda: factura.id_tienda\r\n        };\r\n        const facturaResult: FacturaCreationResult = await consulta.one<FacturaCreationResult>(\r\n          SQL_FACTURAS.createInvoice, \r\n          [\r\n            facturaValues.fecha_venta, \r\n            facturaValues.vendedor_factura, \r\n            facturaValues.cantidad_producto, \r\n            facturaValues.id_tienda\r\n          ]);\r\n\r\n        // Obtiene el id_factura generado\r\n        const id_factura = facturaResult.id_factura;\r\n        console.log(`Factura creada con id: ${id_factura}`);\r\n\r\n        // Verifica que todos los productos existen antes de insertar los detalles\r\n        for (const detalle of detalles) {\r\n          const detalleValues = {\r\n            cantidad_producto: detalle.cantidad_producto, \r\n            fecha_creacion: detalle.fecha_creacion, \r\n            id_factura, \r\n            id_producto: detalle.id_producto\r\n          };\r\n          const productExists = await consulta.oneOrNone(SQL_PRODUCTOS.checkProductExists, [\r\n            detalleValues.id_producto\r\n          ]);\r\n          if (!productExists) {\r\n            throw new Error(`Producto con id ${detalle.id_producto} no existe.`);\r\n          }\r\n        }\r\n\r\n        // Inserta los detalles de la factura\r\n        for (const detalle of detalles) {\r\n          const detalleValues: Omit<DetalleFactura, 'id_detalle_factura'> = {\r\n            cantidad_producto: detalle.cantidad_producto, \r\n            fecha_creacion: detalle.fecha_creacion, \r\n            id_factura, \r\n            id_producto: detalle.id_producto\r\n          };\r\n          await consulta.oneOrNone(SQL_DETALLES.insertNewDetail, [\r\n            detalleValues.cantidad_producto, \r\n            detalleValues.fecha_creacion, \r\n            detalleValues.id_factura, \r\n            detalleValues.id_producto\r\n          ]);\r\n        }\r\n\r\n        return { id_factura };\r\n      });\r\n\r\n      return Result.success(result);\r\n    } catch (error) {\r\n      console.error(`Error al insertar detalles: ${(error as Error).message}`);\r\n      return Result.fail(`No se puede crear la factura con detalles, error: ${(error as Error).message}`);\r\n    }\r\n  }\r\n  // return Result.fail(`No se puede crear la factura con detalles, error: ${(error as Error).message}`);\r\n\r\n  public static async fetchStoreInvoices(id_tienda: number): Promise<Result<DetalleFactura[]>> {\r\n    try {\r\n      const result = await pool.many<DetalleFactura>(SQL_DETALLES.getInvoiceDetailsByStoreAndID, id_tienda);\r\n      return Result.success(result);\r\n    } catch (error) {\r\n      return Result.fail(`No se pueden obtener las facturas de la tienda, ${error}`);\r\n    }\r\n  }\r\n}",
      "FacturaDAO.ts": "import pool from '../config/connection/conexion';\r\nimport { contador, Exists, Factura, FacturaCreationResult } from \"../interface/interfaces\";\r\nimport { SQL_FACTURAS } from '../repository/crudSQL';\r\nimport Result from '../utils/Result';\r\n\r\nexport default class FacturaDAO {\r\n  public static async insertInvoice(data: Factura[]): Promise<Result<FacturaCreationResult>> {\r\n    const existingInvoice: Exists | null = await pool.oneOrNone(SQL_FACTURAS.isInvoiceDuplicate, data);\r\n\r\n    if (existingInvoice?.exists) {\r\n      return Result.fail(\"La factura ya existe\");\r\n    }\r\n\r\n    try {\r\n      const result: FacturaCreationResult = await pool.task(async (consulta) => {\r\n        return await consulta.one<FacturaCreationResult>(SQL_FACTURAS.createInvoice, data);\r\n      });\r\n\r\n      return Result.success({ id_factura: result.id_factura });\r\n    } catch (error) {\r\n      return Result.fail(`No se puede crear la factura, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async fetchStoreInvoices(tienda: number): Promise<Result<Factura[]>> {\r\n    try {\r\n      const respuesta: Factura[] = await pool.manyOrNone(SQL_FACTURAS.getInvoicesByStoreId, tienda);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar las facturas de la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async filterInvoiceIdByStore(tienda: number, id: number): Promise<Result<Factura | null>> {\r\n    try {\r\n      const respuesta: Factura | null = await pool.oneOrNone<Factura>(SQL_FACTURAS.getInvoiceByStoreAndId, [tienda, id]);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar la factura de la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async updateInvoice(fieldsToUpdate: { [key: string]: any }, idFactura: number, tienda: number): Promise<Result<string>> {\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      return Result.fail(\"No se proporcionaron campos para actualizar\");\r\n    }\r\n\r\n    const existingInvoice = await pool.oneOrNone(SQL_FACTURAS.checkInvoiceExists, [tienda, idFactura]);\r\n\r\n    if (!existingInvoice) {\r\n      return Result.fail(\"Factura no encontrada\");\r\n    }\r\n\r\n    try {\r\n      const setClause = Object.keys(fieldsToUpdate)\r\n        .map((field, index) => `${field} = $${index + 1}`)\r\n        .join(\", \");\r\n\r\n      const values = Object.values(fieldsToUpdate);\r\n      values.push(idFactura, tienda);\r\n\r\n      const sqlUpdate = `UPDATE facturas SET ${setClause} WHERE id_factura = $${values.length - 1} AND id_tienda = $${values.length}`;\r\n\r\n      const result = await pool.result(sqlUpdate, values);\r\n\r\n      if (result.rowCount > 0) {\r\n        return Result.success(\"Factura actualizada\");\r\n      } else {\r\n        return Result.fail(\"Factura no encontrada\");\r\n      }\r\n    } catch (error) {\r\n      return Result.fail(`No se puede actualizar la factura, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async deleteInvoice(tienda: number, idFactura: number): Promise<Result<string>> {\r\n    const existingInvoice = await pool.oneOrNone(SQL_FACTURAS.checkInvoiceExists, [tienda, idFactura]);\r\n\r\n    if (!existingInvoice) {\r\n      return Result.fail(\"Factura no encontrada\");\r\n    }\r\n\r\n    try {\r\n      const result = await pool.result(SQL_FACTURAS.deleteInvoice, [tienda, idFactura]);\r\n\r\n      if (result.rowCount > 0) {\r\n        return Result.success(\"Factura eliminada correctamente\");\r\n      } else {\r\n        return Result.fail(\"Factura no encontrada\");\r\n      }\r\n    } catch (error) {\r\n      return Result.fail(`No se puede eliminar la factura, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async countInvoicesTypeByStore(tienda: number, tipo: contador) {\r\n    const queriesByType: Record<contador, string> = {\r\n      \"anual\": SQL_FACTURAS.storeAnnualInvoiceCounter,\r\n      \"mensual\": SQL_FACTURAS.storeMonthlyInvoiceCounter,\r\n      \"diaria\": SQL_FACTURAS.storeDailyInvoiceCounter,\r\n    };\r\n\r\n    const counterSQLQuery = queriesByType[tipo];\r\n\r\n    if (!counterSQLQuery) {\r\n      return Result.fail(`Tipo de contador '${tipo.toUpperCase()}' no válido.`);\r\n    }\r\n\r\n    try {\r\n      const result = await pool.result(counterSQLQuery, [tienda]);\r\n      if (result.rowCount > 0) {\r\n        return Result.success(result.rows[0]);\r\n      } else {\r\n        return Result.fail(`No se encontraron facturas para la tienda ${tienda}`);\r\n      }\r\n    } catch (error) {\r\n      return Result.fail(`Error listando cantidad de facturas ${tipo.toUpperCase()}: ${(error as Error).message}`);\r\n    }\r\n  }\r\n}\r\n",
      "productoDAO.ts": "import pool from '../config/connection/conexion';\r\nimport { Producto, ProductoCreationResult } from '../interface/interfaces';\r\nimport { SQL_PRODUCTOS } from '../repository/crudSQL';\r\nimport Result from '../utils/Result';\r\n\r\nexport default class productoDAO {\r\n  public static async insertProduct(data: Producto[]): Promise<Result<ProductoCreationResult>> {\r\n    try {\r\n      const existingProduct = await pool.oneOrNone(SQL_PRODUCTOS.isProductDuplicate, [\r\n        data[0].nombre, \r\n        data[0].marca, \r\n        data[0].precio_unitario, \r\n        data[0].fecha_caducidad, \r\n        data[0].descripcion, \r\n        data[0].stock, \r\n        data[0].id_categoria, \r\n        data[0].id_tienda\r\n      ]);\r\n\r\n      if (existingProduct?.cantidad > 0) {\r\n        return Result.fail(\"El producto ya existe\");\r\n      }\r\n\r\n      const result: ProductoCreationResult = await pool.task(async (consulta) => {\r\n        return await consulta.one<ProductoCreationResult>(SQL_PRODUCTOS.CREAR, data);\r\n      });\r\n\r\n      return Result.success({ id_producto: result.id_producto });\r\n    } catch (error) {\r\n      return Result.fail(`No se puede crear el producto, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async fetchProducts(tienda: number): Promise<Result<Producto[]>> {\r\n    try {\r\n      const respuesta: Producto[] = await pool.manyOrNone(SQL_PRODUCTOS.getProductsByStoreId, tienda);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar los productos, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async filterProductById(tienda: number, idProducto: number): Promise<Result<Producto | null>> {\r\n    try {\r\n      const respuesta: Producto | null = await pool.oneOrNone<Producto>(SQL_PRODUCTOS.LISTARPORID, [tienda, idProducto]);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar el producto, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async updateProduct(fieldsToUpdate: { [key: string]: any }, idProducto: number, tienda: number): Promise<Result<void>> {\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      return Result.fail(\"No se proporcionaron campos para actualizar\");\r\n    }\r\n\r\n    const existingProduct = await pool.oneOrNone(SQL_PRODUCTOS.checkProductExists, [tienda, idProducto]);\r\n\r\n    if (!existingProduct) {\r\n      return Result.fail(\"Producto no encontrado\");\r\n    }\r\n    \r\n    try {\r\n      const setClause = Object.keys(fieldsToUpdate)\r\n        .map((field, index) => `${field} = $${index + 1}`)\r\n        .join(\", \");\r\n\r\n      const values = Object.values(fieldsToUpdate);\r\n      values.push(tienda, idProducto);\r\n\r\n      await pool.query(SQL_PRODUCTOS.ACTUALIZAR + setClause, values);\r\n      return Result.success();\r\n    } catch (error) {\r\n      return Result.fail(`No se puede actualizar el producto, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async deleteProduct(tienda: number, idProducto: number): Promise<Result<void>> {\r\n    const existingProduct = await pool.oneOrNone(SQL_PRODUCTOS.checkProductExists, [tienda, idProducto]);\r\n\r\n    if (!existingProduct) {\r\n      return Result.fail(\"Producto no encontrado\");\r\n    }\r\n\r\n    try {\r\n      await pool.query(SQL_PRODUCTOS.ELIMINAR, idProducto);\r\n      return Result.success();\r\n    } catch (error) {\r\n      return Result.fail(`No se puede eliminar el producto, ${error}`);\r\n    }\r\n  }\r\n}\r\n",
      "tiendaDAO.ts": "import pool from \"../config/connection/conexion\";\r\nimport { Empleados, Exists, Tienda, TiendaCreationResult } from \"../interface/interfaces\";\r\nimport { SQL_TIENDAS } from \"../repository/crudSQL\";\r\nimport Result from \"../utils/Result\";\r\n\r\nexport default class tiendaDAO {\r\n  public static async addNewStore(data: Tienda[]): Promise<Result<TiendaCreationResult>> {\r\n    try {\r\n      const existingStore: Exists | null = await pool.oneOrNone(SQL_TIENDAS.isStoreDuplicate, [\r\n        data[0].nombre_tienda,\r\n        data[0].direccion_tienda,\r\n        data[0].telefono_tienda,\r\n        data[0].propietario_tienda\r\n      ]);\r\n\r\n      if (existingStore?.exists) {\r\n        return Result.fail(\"La tienda ya existe\");\r\n      }\r\n\r\n      const result: TiendaCreationResult = await pool.task(async (consulta) => {\r\n        return await consulta.one(SQL_TIENDAS.createStore, data);\r\n      });\r\n\r\n      return Result.success({ id_tienda: result.id_tienda });\r\n    } catch (error) {\r\n      return Result.fail(`No se puede crear la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async fetchStores(): Promise<Result<Tienda[]>> {\r\n    try {\r\n      const respuesta: Tienda[] = await pool.manyOrNone(SQL_TIENDAS.getStores);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar las tiendas, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async filterStoreById(idStore: number): Promise<Result<Tienda | null>> {\r\n    try {\r\n      const respuesta: Tienda | null = await pool.oneOrNone<Tienda>(SQL_TIENDAS.getStoreById, idStore);\r\n      return Result.success(respuesta);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async fetchEmployeeCounterStores(limit: number, offset: number) {\r\n    try {\r\n      const totalRecords = await pool.one(SQL_TIENDAS.countTotalRecords);\r\n      const respuesta: Empleados[] = await pool.manyOrNone(SQL_TIENDAS.employeeCounter, [limit, offset]);\r\n      let nextOffset = offset + limit;\r\n      const moreRecordsAvailable = nextOffset < totalRecords;\r\n      if (respuesta.length > 0 || moreRecordsAvailable) {\r\n        return Result.success(respuesta);\r\n      } else {\r\n        return Result.fail(\"No hay más registros disponibles.\");\r\n      }\r\n    } catch (error) {\r\n      return Result.fail(`No se puede listar las tiendas, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async updateStore(fieldsToUpdate: { [key: string]: any }, idStore: number): Promise<Result<void>> {\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      return Result.fail(\"No se proporcionaron campos para actualizar\");\r\n    }\r\n\r\n    const existingStore = await pool.oneOrNone(SQL_TIENDAS.checkStoreExists, idStore);\r\n\r\n    if (!existingStore) {\r\n      return Result.fail(\"Tienda no encontrada\");\r\n    }\r\n\r\n    try {\r\n      const setClause = Object.keys(fieldsToUpdate)\r\n        .map((field, index) => `${field} = $${index + 1}`)\r\n        .join(\", \");\r\n\r\n      await pool.query(`UPDATE tiendas SET ${setClause} WHERE id_tienda = $${Object.keys(fieldsToUpdate).length + 1}`, [...Object.values(fieldsToUpdate), idStore]);\r\n      return Result.success();\r\n    } catch (error) {\r\n      return Result.fail(`Error actualizando la tienda, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async deleteStore(idStore: number): Promise<Result<void>> {\r\n    const existingStore = await pool.oneOrNone(SQL_TIENDAS.checkStoreExists, idStore);\r\n\r\n    if (!existingStore) {\r\n      return Result.fail(\"Tienda no encontrada\");\r\n    }\r\n\r\n    try {\r\n      await pool.query(SQL_TIENDAS.deleteStore, idStore);\r\n      return Result.success();\r\n    } catch (error) {\r\n      return Result.fail(`Error eliminando la tienda, ${error}`);\r\n    }\r\n  }\r\n}\r\n",
      "tokenDAO.ts": "import { config } from \"dotenv\";\r\nimport Jwt from \"jsonwebtoken\";\r\nimport pool from \"../config/connection/conexion\";\r\nimport { DataToken, Token } from \"../interface/interfaces\";\r\nimport { SQL_TOKEN } from \"../repository/crudSQL\";\r\nimport Result from \"../utils/Result\";\r\n\r\nconfig({ path: \"./.env\" });\r\n\r\nexport default class tokenDAO {\r\n  public static async generateToken(data: Token[]): Promise<Result<string>> {\r\n    try {\r\n      const result = await pool.result(SQL_TOKEN.getUserToken, \r\n        data\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        return Result.fail(\"No se encontraron registros\");\r\n      }\r\n\r\n      const { username, id_tienda, nombre_rol } = result.rows[0] as DataToken;\r\n      const secretKey = process.env.JWT_SECRET_KEY || 'LaSuperClave';\r\n\r\n      const token = Jwt.sign(\r\n        { username, id_tienda, nombre_rol },\r\n        secretKey,\r\n        { expiresIn: \"10000d\" }\r\n      );\r\n\r\n      return Result.success(token);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede generar el token, ${(error as Error).message}`);\r\n    }\r\n  }\r\n}",
      "usuarioDAO.ts": "import pool from \"../config/connection/conexion\";\r\nimport { Usuario, UsuarioBulkResult, UsuarioCreationResult, UsuarioR } from \"../interface/interfaces\";\r\nimport { SQL_USUARIO } from \"../repository/crudSQL\";\r\nimport Result from \"../utils/Result\";\r\n\r\nexport default class UsuarioDAO {\r\n  public static async createUser(data: Omit<Usuario, 'id_usuario'>): Promise<Result<UsuarioCreationResult>> {\r\n    const {username, password, id_tienda, id_rol} = data;\r\n    const existingUser = await pool.oneOrNone(SQL_USUARIO.checkUserExists, [username, id_tienda]);\r\n\r\n    if (existingUser?.exists) {\r\n      return Result.fail(\"El usuario ya existe\");\r\n    }\r\n\r\n    try {\r\n      const result: UsuarioCreationResult = await pool.task(async (consulta) => {\r\n        return await consulta.one<UsuarioCreationResult>(SQL_USUARIO.insertUser, [username, password, id_tienda, id_rol]);\r\n      });\r\n\r\n      return Result.success({ id_usuario: result.id_usuario });\r\n    } catch (error) {\r\n      return Result.fail(`No se puede crear el usuario, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async createUsers(data: Omit<Usuario, 'id_usuario'>[]): Promise<Result<UsuarioBulkResult>> {\r\n    const created: UsuarioCreationResult[] = [];\r\n    const errors: string[] = [];\r\n\r\n    for (const user of data) {\r\n      const { username, password, id_tienda, id_rol } = user;\r\n      const existingUser = await pool.oneOrNone(SQL_USUARIO.checkUserExists, [username, id_tienda]);\r\n\r\n      if (existingUser) {\r\n        errors.push(`El usuario ${username} ya existe en la tienda ${id_tienda}`);\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        const result: UsuarioCreationResult = await pool.task(async (consulta) => {\r\n          return await consulta.one<UsuarioCreationResult>(SQL_USUARIO.insertUser, [username, password, id_tienda, id_rol]);\r\n        });\r\n        created.push({ id_usuario: result.id_usuario });\r\n      } catch (error) {\r\n        errors.push(`No se puede crear el usuario ${username}, ${error}`);\r\n      }\r\n    }\r\n    return Result.success({ created, errors });\r\n  }\r\n\r\n  public static async fetchUsers(tienda: number): Promise<Result<Usuario[]>> {\r\n    try {\r\n      const result: Usuario[] = await pool.manyOrNone(SQL_USUARIO.fetchUsers, tienda);\r\n      return Result.success(result);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede obtener los usuarios, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async finAllUsers(): Promise<Result<UsuarioR[]>> {\r\n    try {\r\n      const result: UsuarioR[] = await pool.manyOrNone(SQL_USUARIO.findAllUsers);\r\n      return Result.success(result);\r\n    } catch (error) {\r\n      return Result.fail(`No se puede obtener los usuarios, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async filterUserByStoreAndId(tienda: number, idUsuario: number): Promise<Result<Usuario | null>> {\r\n    try {\r\n      const result: Usuario | null = await pool.oneOrNone(SQL_USUARIO.findUserByStoreAndId, [idUsuario, tienda]);\r\n      return Result.success(result);\r\n    }catch(error){\r\n      return Result.fail(`No se puede obtener el usuario, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async updateUser(fieldsToUpdate: { [key: string]: any }, idUsuario: number, tienda: number): Promise<Result<void>> {\r\n    if (Object.keys(fieldsToUpdate).length === 0) {\r\n      return Result.fail(\"No se proporcionaron campos para actualizar\");\r\n    }\r\n\r\n    const existingUser = await pool.oneOrNone(SQL_USUARIO.checkUserExists, [idUsuario, tienda]);\r\n\r\n    if (!existingUser) {\r\n      return Result.fail(\"Usuario no encontrado\");\r\n    }\r\n\r\n    try {\r\n      const setClause = Object.keys(fieldsToUpdate)\r\n        .map((field, index) => `${field} = $${index + 1}`)\r\n        .join(\", \");\r\n      \r\n      const values = Object.values(fieldsToUpdate);\r\n      values.push(idUsuario, tienda);\r\n\r\n      const sqlUpdate = `UPDATE usuarios SET ${setClause} WHERE id_usuario = $${values.length - 1} AND id_tienda = $${values.length}`;\r\n\r\n      await pool.query(sqlUpdate, values);\r\n      return Result.success();\r\n    } catch (error) {\r\n      return Result.fail(`No se puede actualizar el usuario, ${error}`);\r\n    }\r\n  }\r\n\r\n  public static async deleteUser(tienda: number, idUsuario: number) {\r\n    const existingUser = await pool.oneOrNone(SQL_USUARIO.checkUserExists, [idUsuario, tienda]);\r\n\r\n    if (!existingUser) {\r\n      return Result.fail(\"Usuario no encontrado\");\r\n    }\r\n\r\n    try {\r\n      await pool.query(SQL_USUARIO.deleteUser, [idUsuario, tienda]);\r\n      return Result.success();\r\n    } catch (error) {\r\n      return Result.fail(`No se puede eliminar el usuario, ${error}`);\r\n    }\r\n  }\r\n}"
    },
    "index.ts": "import Server from \"./config/api/Server\";\r\n\r\nconst server = new Server();\r\n\r\nserver.arrancar();\r\n",
    "interface": {
      "interfaces.ts": "export type contador = \"anual\" | \"mensual\" | \"diaria\"\r\n\r\nexport interface Rol {\r\n  id_rol: number;\r\n  nombre_rol: string;\r\n}\r\n\r\nexport interface Tienda {\r\n  id_tienda: number;\r\n  nombre_tienda: string;\r\n  direccion_tienda: string;\r\n  telefono_tienda: string;\r\n  propietario_tienda: string;\r\n}\r\n\r\nexport interface Categoria {\r\n  id_categoria: number;\r\n  nombre: string;\r\n  descripcion: string;\r\n  id_tienda: number;\r\n}\r\n\r\nexport interface Factura {\r\n  id_factura?: number;\r\n  fecha_venta: Date;\r\n  vendedor_factura: string;\r\n  cantidad_producto: number;\r\n  id_tienda: number;\r\n}\r\n\r\nexport interface Producto {\r\n  id_producto: number;\r\n  nombre: string;\r\n  marca: string;\r\n  precio_unitario: number;\r\n  fecha_caducidad: string;\r\n  descripcion: string;\r\n  stock: number;\r\n  id_categoria: number;\r\n  id_tienda: number;\r\n}\r\n\r\nexport interface Usuario {\r\n  id_usuario: number;\r\n  username: string;\r\n  password: string;\r\n  id_tienda: number;\r\n  id_rol: number;\r\n}\r\n\r\nexport interface UsuarioBulkResult {\r\n  created: UsuarioCreationResult[];\r\n  errors: string[];\r\n}\r\n\r\nexport interface UsuarioR {\r\n  id_usuario: number;\r\n  rol: string;\r\n  username: string;\r\n  tienda: string;\r\n}\r\n\r\nexport interface DetalleFactura {\r\n  id_detalle_factura?: number;\r\n  cantidad_producto: number;\r\n  fecha_creacion: Date;\r\n  id_factura?: number;\r\n  id_producto: number;\r\n}\r\n\r\nexport interface Token {\r\n  username: string;\r\n  password: string;\r\n}\r\n\r\nexport interface DataToken{\r\n  username: string;\r\n  id_tienda: number;\r\n  nombre_rol: string;\r\n}\r\n\r\nexport interface Empleados{\r\n  id: number;\r\n  tienda: string;\r\n  \"# empleados\": number;\r\n}\r\n\r\nexport interface Exists{\r\n  exists: boolean;\r\n}\r\n\r\nexport interface CategoriaCreationResult {\r\n  id_categoria: number;\r\n}\r\n\r\nexport interface FacturaCreationResult {\r\n  id_factura: number;\r\n}\r\n\r\nexport interface DetalleFacturaCreationResult {}\r\n\r\nexport interface TiendaCreationResult {\r\n  id_tienda: number;\r\n}\r\n\r\nexport interface ProductoCreationResult {\r\n  id_producto: number;\r\n}\r\n\r\nexport interface RolCreationResult {}\r\n\r\nexport interface UsuarioCreationResult {\r\n  id_usuario: number;\r\n}\r\n"
    },
    "middleware": {
      "Seguridad.ts": "import jwt from \"jsonwebtoken\";\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport { config } from \"dotenv\";\r\n\r\nconfig({ path: \"./.env\" });\r\n\r\nclass Seguridad {\r\n  public revisar(req: Request, res: Response, next: NextFunction) {\r\n    const authHeader = req.headers.authorization;\r\n\r\n    if (!authHeader) {\r\n      return res.status(401).json({ Respuesta: \"Falta el token de autorización\" });\r\n    }\r\n\r\n    const tokenParts = authHeader.split(\" \");\r\n    if (tokenParts.length !== 2 || tokenParts[0] !== \"Bearer\") {\r\n      return res.status(401).json({ Respuesta: \"Formato del token incorrecto\" });\r\n    }\r\n\r\n    const token = tokenParts[1];\r\n    try {\r\n      const secretKey = process.env.JWT_SECRET_KEY || 'LaSuperClave';\r\n      const decoded = jwt.verify(token, secretKey);\r\n      (req as any).user = decoded; // Attach decoded token to the request object\r\n      next();\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        return res.status(401).json({ Respuesta: \"El token ha expirado\" });\r\n      } else if (error instanceof jwt.JsonWebTokenError) {\r\n        return res.status(401).json({ Respuesta: \"El token no es válido\" });\r\n      } else {\r\n        return res.status(500).json({ Respuesta: \"Error al procesar el token\" });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst seguridad = new Seguridad();\r\nexport default seguridad;\r\n"
    },
    "repository": {
      "crudSQL.ts": "export const SQL_CATEGORIAS = {\r\n    createCategory: \"INSERT INTO categorias (nombre, descripcion, id_tienda) VALUES ($1,$2,$3) RETURNING id_categoria\",\r\n    checkCategoryExists: \"SELECT 1 FROM categorias WHERE id_tienda = $1 AND id_categoria = $2\",\r\n    getCategoriesByStoreId: \"SELECT id_categoria, nombre, descripcion, id_tienda FROM categorias where id_tienda = $1\",\r\n    getCategoriesByStoreAndId: \"SELECT id_categoria, nombre, descripcion, id_tienda FROM categorias WHERE id_tienda = $1 AND id_categoria = $2\",\r\n    isCategoryDuplicate: \"SELECT COUNT(*) > 0 AS exists FROM categorias WHERE lower(nombre) = lower($1) and lower(descripcion) = lower($2) and id_tienda = $3;\",\r\n    deleteCategory: \"DELETE FROM categorias e WHERE e.id_categoria = $1\",\r\n    getProductsByStock: \"SELECT c.nombre, p.nombre, p.marca FROM categorias c JOIN productos p ON c.id_categoria = p.id_categoria WHERE p.stock = $1\",\r\n};\r\n\r\nexport const SQL_DETALLES = {\r\n    getInvoiceDetailsByStoreAndID: \"SELECT * FROM detalles_facturas where id_tienda = $1 and id_factura = $2\",\r\n    insertNewDetail: \"INSERT INTO detalles_facturas (cantidad_producto, fecha_creacion, id_factura, id_producto) VALUES($1, $2, $3, $4)\",\r\n};\r\n\r\nexport const SQL_FACTURAS = {\r\n    createInvoice: \"INSERT INTO facturas (fecha_venta, vendedor_factura, cantidad_producto, id_tienda) VALUES ($1, $2, $3, $4) RETURNING id_factura\",\r\n    isInvoiceDuplicate: \"SELECT COUNT(*) > 0 AS exists FROM facturas WHERE fecha_venta = $1 and lower(vendedor_factura) = lower($2) and cantidad_producto = lower($3) and lower(id_tienda) = lower($4)\",\r\n    checkInvoiceExists: \"SELECT 1 FROM facturas WHERE id_tienda = $1 AND id_factura = $2\",\r\n    getTotalSales: \"SELECT f.id_factura, f.fecha_venta, SUM(p.precio_unitario * f.cantidad_producto) AS total_venta FROM facturas f JOIN productos p ON f.id_factura = p.id_factura GROUP BY f.id_factura, f.fecha_venta\",\r\n    getInvoicesByStoreId: \"SELECT id_factura, fecha_venta, vendedor_factura, cantidad_producto, id_tienda FROM facturas WHERE id_tienda = $1\",\r\n    getInvoiceByStoreAndId: \"SELECT id_factura, fecha_venta, vendedor_factura, cantidad_producto, id_tienda FROM facturas WHERE id_tienda = $1 AND id_factura = $2\",\r\n    deleteInvoice: \"DELETE FROM facturas WHERE id_tienda = $1 and id_factura = $2\",\r\n\r\n    storeAnnualInvoiceCounter: \"SELECT COUNT(*) FILTER (WHERE EXTRACT(YEAR FROM fecha_venta) = EXTRACT(YEAR FROM current_date) AND id_tienda = $1) AS facturas_anuales FROM facturas;\", \r\n    storeMonthlyInvoiceCounter: \"SELECT COUNT(*) FILTER (WHERE EXTRACT(MONTH FROM fecha_venta) = EXTRACT(MONTH FROM current_date) AND id_tienda = $1) AS facturas_mensuales FROM facturas;\",\r\n    storeDailyInvoiceCounter: \"SELECT COUNT(*) FILTER (WHERE fecha_venta::DATE = current_date::DATE AND id_tienda = $1) AS facturas_diarias FROM facturas;\"\r\n};\r\n\r\nexport const SQL_PRODUCTOS = {\r\n    getProductsByStoreId: \"SELECT * FROM productos where id_tienda = $1\",\r\n    CREAR: \"INSERT INTO productos (nombre, marca, precio_unitario, fecha_caducidad, descripcion, stock, id_categoria, id_tienda) VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING id_producto\",\r\n    checkProductExists: \"SELECT 1 FROM productos WHERE id_tienda = $1 AND id_producto = $2\",\r\n    isProductDuplicate: \"SELECT COUNT(*) > 0 AS exists FROM productos WHERE lower(nombre) = lower($1) and lower(marca) = lower($2) and precio_unitario = $3 and fecha_caducidad = $4 and lower(descripcion) = lower($5) and stock = $6 and id_categoria = $7 and id_tienda = $8\",\r\n    ELIMINAR: \"DELETE FROM productos e WHERE e.id_producto = $1\",\r\n    ACTUALIZAR: \"UPDATE productos SET nombre = $1, marca = $2, precio_unitario = $3, fecha_caducidad = $4, descripcion = $5, stock = $6, id_categoria = $7, id_tienda = $8 WHERE id_producto = $9\",\r\n    VARIEDAD: \"SELECT c.nombre, COUNT(DISTINCT p.id_producto) AS num_productos FROM categorias c JOIN productos p ON c.id_categoria = p.id_categoria GROUP BY c.nombre;\",\r\n    DATE_SQL: \"SELECT f.fecha_venta, SUM(f.cantidad_producto) FROM facturas f WHERE f.fecha_venta BETWEEN $1 AND $2 GROUP BY f.fecha_venta\",\r\n    LISTARPORID: \"SELECT * FROM productos WHERE id_tienda = $1\",\r\n    checkProductExistsID: \"SELECT 1 FROM productos WHERE id_producto = $1\"\r\n};\r\n\r\nexport const SQL_ROL = {\r\n    LISTAR_TODOS: \"SELECT * FROM roles\",\r\n    CREAR: \"INSERT INTO roles (nombre_rol) VALUES($1) RETURNING id_rol\",\r\n    VERIFICAR:\r\n        \"SELECT COUNT(r.id_rol) AS cantidad FROM roles r WHERE lower(r.nombre_rol) = lower($1)\",\r\n    EDITAR: \"UPDATE roles SET nombre_rol = $1 WHERE id_rol = $2\",\r\n    LISTARPORID: \"SELECT * FROM roles WHERE id_rol=$1\",\r\n};\r\n\r\nexport const SQL_TIENDAS = {\r\n    createStore: \"INSERT INTO tiendas (nombre_tienda, direccion_tienda, telefono_tienda) VALUES ($1, $2, $3) RETURNING id_tienda\",\r\n    checkStoreExists: \"SELECT 1 FROM tiendas WHERE id_tienda = $1\",\r\n    isStoreDuplicate: \"SELECT COUNT(*) > 0 AS exists FROM tiendas WHERE lower(nombre_tienda) = lower($1) and lower(direccion_tienda) = lower($2) and lower(telefono_tienda) = lower($3) and lower(propietario_tienda) = lower($4)\",\r\n    getStores: \"SELECT id_tienda, nombre_tienda, direccion_tienda, telefono_tienda FROM tiendas\",\r\n    getStoreById: \"SELECT id_tienda, nombre_tienda, direccion_tienda, telefono_tienda FROM tiendas WHERE id_tienda = $1\",\r\n    employeeCounter: `SELECT t.id_tienda as \"id\", t.nombre_tienda as \"tienda\", COUNT(u.id_usuario)::integer as \"# empleados\" FROM tiendas t JOIN usuarios u ON t.id_tienda = u.id_tienda GROUP BY t.id_tienda, t.nombre_tienda ORDER BY t.id_tienda ASC LIMIT $1 OFFSET $2;`,\r\n    countTotalRecords:\"SELECT COUNT(*) FROM usuarios\",\r\n    deleteStore: \"DELETE FROM tiendas WHERE id_tienda = $1\",\r\n}\r\n\r\nexport const SQL_TOKEN ={\r\n    getUserToken: \"SELECT u.username, u.id_tienda, r.nombre_rol FROM usuarios u INNER JOIN roles r ON r.id_rol = u.id_rol where u.username = $1 and u.password = $2\",\r\n};\r\n\r\nexport const SQL_USUARIO = {\r\n    fetchUsers: \"SELECT id_usuario, username, password, id_tienda, id_rol FROM usuarios WHERE id_tienda = $1 ORDER BY id_rol ASC, id_usuario ASC\",\r\n    findAllUsers: \"SELECT usuarios.id_usuario, roles.nombre_rol as rol, usuarios.username, tiendas.nombre_tienda as tienda FROM usuarios JOIN roles ON usuarios.id_rol = roles.id_rol JOIN tiendas ON usuarios.id_tienda = tiendas.id_tienda;\",\r\n    insertUser: \"INSERT INTO usuarios (username, password, id_tienda, id_rol) VALUES($1, $2, $3, $4) RETURNING id_usuario\",\r\n    checkUserExists: \"SELECT 1 FROM usuarios WHERE username = $1 and id_tienda = $2\",\r\n    isUserDuplicate: \"SELECT COUNT(u.id_usuario) AS cantidad FROM usuarios u WHERE lower(u.username) = lower($1) and lower(u.password) = lower($2) and u.id_tienda = $3 and u.id_rol = $4\",\r\n    updateUser: \"UPDATE usuarios SET username = $1,password= $2,id_tienda= $3,id_rol=$4 WHERE id_usuario = $5\",\r\n    roleUsersCount: \"SELECT r.nombre_rol, COUNT(ru.id_usuario) FROM roles r JOIN roles_usuarios ru ON r.id_rol = ru.id_rol GROUP BY r.nombre_rol;\",\r\n    findUserByUsernameAndPassword: \"SELECT * FROM usuarios WHERE username = $1 AND password = $2;\",\r\n    getUsersByStoreId: \"SELECT usuarios.id_usuario, roles.nombre_rol as rol, usuarios.username, tiendas.nombre_tienda as tienda FROM usuarios JOIN roles ON usuarios.id_rol = roles.id_rol JOIN tiendas ON usuarios.id_tienda = tiendas.id_tienda WHERE id_tienda=$1\",\r\n    findUserById: \"SELECT * FROM usuarios WHERE id_usuario=$1\",\r\n    findUserByStoreAndId: \"SELECT * FROM usuarios WHERE id_usuario=$1 AND id_tienda=$2\",\r\n    deleteUser: \"DELETE FROM usuarios WHERE id_usuario = $1 and id_tienda = $2\",\r\n};"
    },
    "routes": {
      "rutasCategorias.ts": "import { Router } from \"express\";\r\n\r\nimport categoriaController from \"../controllers/categoriaController\";\r\n\r\nclass RutasCategorias {\r\n    public rutasApi: Router;\r\n    \r\n    constructor() {\r\n        this.rutasApi = Router();\r\n        this.config();\r\n    }\r\n    \r\n    public config() {\r\n        this.rutas();\r\n    }\r\n    \r\n    public rutas() {\r\n        // /api/public/categorias\r\n        this.rutasApi.post(\"/\", categoriaController.insertCategory);\r\n        this.rutasApi.get(\"/:idTienda\", categoriaController.getStoreCategories);\r\n        this.rutasApi.get(\"/:idTienda/:idCategoria\", categoriaController.getFilteredCategoryByStoreAndId);\r\n        this.rutasApi.patch(\"/:idTienda/:idCategoria\", categoriaController.patchStoreCategory);\r\n        this.rutasApi.delete(\"/:idTienda/:idCategoria\", categoriaController.deleteStoreCategoryId);\r\n    }   \r\n}\r\nconst misRutas = new RutasCategorias();\r\nexport default misRutas.rutasApi;",
      "rutasDetalles.ts": "import { Router } from \"express\";\r\n\r\nimport detallesFacturaController from \"../controllers/detallesFacturaController\";\r\n\r\nclass RutasDetalles {\r\n  public rutasApi: Router;\r\n\r\n  constructor() {\r\n    this.rutasApi = Router();\r\n    this.config();\r\n  }\r\n\r\n  public config() {\r\n    this.rutas();\r\n  }\r\n\r\n  public rutas() {\r\n    this.rutasApi.post(\"/\", detallesFacturaController.insertInvoiceWithDetails);\r\n    this.rutasApi.get(\"/:idTienda\", detallesFacturaController.getStoreInvoices);\r\n  }\r\n}\r\n\r\nconst misRutas = new RutasDetalles();\r\nexport default misRutas.rutasApi;",
      "rutasFacturas.ts": "import { Router } from \"express\";\r\n\r\nimport controladorFacturas from \"../controllers/FacturaController\"; \r\n\r\nclass RutasFacturas {\r\n    public rutasApi: Router;\r\n\r\n    constructor() {\r\n        this.rutasApi = Router();\r\n        this.config();\r\n    }\r\n\r\n    public config() {\r\n        this.rutas();\r\n    }\r\n\r\n    public rutas() {\r\n        this.rutasApi.get(\"/:idTienda\", controladorFacturas.getStoreInvoices);\r\n        this.rutasApi.get(\"/:idTienda/annual\", controladorFacturas.getStoreAnnualInvoices);\r\n        this.rutasApi.get(\"/:idTienda/monthly\", controladorFacturas.getStoreMonthlyInvoices);\r\n        this.rutasApi.get(\"/:idTienda/daily\", controladorFacturas.getStoreDailyInvoices);\r\n        this.rutasApi.get(\"/:idTienda/:idFactura\", controladorFacturas.getFilteredInvoicesByStoreAndId);\r\n        this.rutasApi.patch(\"/:idTienda/:idFactura\", controladorFacturas.patchStoreInvoice);\r\n        this.rutasApi.delete(\"/:idTienda/:idFactura\", controladorFacturas.deleteStoreInvoiceId);\r\n    }\r\n}\r\nconst misRutas = new RutasFacturas();\r\nexport default misRutas.rutasApi;",
      "rutasProductos.ts": "import { Router } from \"express\";\r\n\r\nimport ProductoController from \"../controllers/productoController\";\r\n\r\nclass RutasProductos {\r\n    public rutasApi: Router;\r\n    constructor() {\r\n        this.rutasApi = Router();\r\n        this.config();\r\n    }\r\n    public config() {\r\n        this.rutas();\r\n    }\r\n    public rutas() {\r\n        this.rutasApi.post(\"/\", ProductoController.createProduct)\r\n        this.rutasApi.get(\"/:idTienda\", ProductoController.fetchProducts)\r\n        this.rutasApi.get(\"/:idTienda/:idProducto\", ProductoController.filterProductById)\r\n        this.rutasApi.patch(\"/:idTienda/:idProducto\", ProductoController.updateProduct)\r\n        this.rutasApi.delete(\"/:idTienda/:idProducto\", ProductoController.deleteProduct)\r\n    }\r\n}\r\nconst misRutas = new RutasProductos();\r\nexport default misRutas.rutasApi;\r\n",
      "rutasTienda.ts": "import { Router } from \"express\";\r\n\r\nimport tiendaController from \"../controllers/tiendaController\";\r\n\r\nclass Rutas {\r\n    public rutasApi: Router;\r\n\r\n    constructor() {\r\n        this.rutasApi = Router();\r\n        //cargar el inico de la config de rutas\r\n        this.config();\r\n    }\r\n\r\n    public config() {\r\n        this.rutas();\r\n    }\r\n\r\n    public rutas() {\r\n        // /api/public/tiendas\r\n        this.rutasApi.post(\"/\", tiendaController.insertStore);\r\n        this.rutasApi.get(\"/\", tiendaController.fetchStores);\r\n        this.rutasApi.get(\"/empleados\", tiendaController.fetchEmployeeCounterStores);\r\n        this.rutasApi.get(\"/:idTienda\", tiendaController.filterStoreById);\r\n        this.rutasApi.patch(\"/:idTienda\", tiendaController.patchStore);\r\n        this.rutasApi.delete(\"/:idTienda\", tiendaController.deleteStore);\r\n    }\r\n}\r\n\r\nconst misRutas = new Rutas();\r\nexport default misRutas.rutasApi;\r\n",
      "rutasUsuario.ts": "import { Router } from \"express\";\r\n\r\nimport UsuarioController from \"../controllers/usuarioController\";\r\n\r\nclass Rutas {\r\n    public rutasApi: Router;\r\n\r\n    constructor() {\r\n        this.rutasApi = Router();\r\n        this.config();\r\n    }\r\n\r\n    public config() {this.rutas();}\r\n    public rutas() {\r\n        this.rutasApi.post(\"/\", UsuarioController.insertUser);\r\n        this.rutasApi.post(\"/many\", UsuarioController.insertUsers);\r\n        this.rutasApi.get(\"/\", UsuarioController.findAllUsers);\r\n        this.rutasApi.get(\"/:idTienda\", UsuarioController.fetchUsers);\r\n        this.rutasApi.get(\"/:idTienda/:idUsuario\", UsuarioController.findUser);\r\n        this.rutasApi.patch(\"/:idTienda/:idUsuario\", UsuarioController.patchUser);\r\n        this.rutasApi.delete(\"/:idTienda/:idUsuario\", UsuarioController.deleteUser);\r\n    }\r\n}\r\n\r\nconst misRutas = new Rutas();\r\nexport default misRutas.rutasApi;\r\n",
      "TokenRuta.ts": "import { Router } from \"express\";\r\n\r\nimport TokenController from \"../controllers/tokenController\";\r\n\r\nclass TokenRuta {\r\n  public tokenRutaApi: Router;\r\n\r\n  constructor() {\r\n    this.tokenRutaApi = Router();\r\n    this.lasRutas();\r\n  }\r\n\r\n  public lasRutas(): void {\r\n    // /api/public/token\r\n    this.tokenRutaApi.post(\"/\", TokenController.createToken);\r\n  }\r\n}\r\nconst tokenRuta = new TokenRuta();\r\nexport default tokenRuta.tokenRutaApi;"
    },
    "utils": {
      "Result.ts": "class Result<T, E = string> {\r\n  public isSuccess: boolean;\r\n  public isFailure: boolean;\r\n  public error: E | null;\r\n  private value: T | null;\r\n\r\n  private constructor(isSuccess: boolean, error?: E, value?: T) {\r\n    if (isSuccess && error) {\r\n      throw new Error(\"InvalidOperation: A result cannot be successful and contain an error\");\r\n    }\r\n    if (!isSuccess && !error) {\r\n      throw new Error(\"InvalidOperation: A failing result needs to contain an error message\");\r\n    }\r\n\r\n    this.isSuccess = isSuccess;\r\n    this.isFailure = !isSuccess;\r\n    this.error = error || null;\r\n    this.value = value || null;\r\n  }\r\n\r\n  public getValue(): T {\r\n    if (!this.isSuccess) {\r\n      throw new Error(\"Can't get the value of an error result. Use 'errorValue' instead.\");\r\n    }\r\n\r\n    return this.value as T;\r\n  }\r\n\r\n  public errorValue(): E {\r\n    return this.error as E;\r\n  }\r\n\r\n  public static success<U>(value?: U): Result<U> {\r\n    return new Result<U>(true, undefined, value);\r\n  }\r\n\r\n  public static fail<U, F>(error: F): Result<U, F> {\r\n    return new Result<U, F>(false, error);\r\n  }\r\n}\r\n\r\nexport default Result;\r\n"
    }
  }
}